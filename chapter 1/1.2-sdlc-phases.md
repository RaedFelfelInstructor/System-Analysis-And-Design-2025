# 1.2 SDLC Phases Explained

[‚Üê Previous: 1.1 Why SDLC Matters](./1.1-why-sdlc-matters.md) | [Back to README](./chapter-01-README.md) | [Next: 1.3 Traditional Models ‚Üí](./1.3-traditional-models.md)

---

## üìñ Introduction

Now that you understand why SDLC matters, let's explore what actually happens during software development. Every software project‚Äîfrom a simple mobile app to a complex enterprise system‚Äîgoes through distinct phases. Understanding these phases helps you know where you are in a project, what activities to perform, and what deliverables to produce.

Think of SDLC phases like building a house: you don't start painting walls before pouring the foundation. Similarly, software development follows a logical sequence of activities.

**Reading Time:** 30 minutes  
**Activity Time:** 15 minutes

---

## üéØ Learning Objectives

By the end of this section, you will be able to:

1. Identify and describe all seven phases of the SDLC
2. Explain the purpose and key activities of each phase
3. Recognize the deliverables produced in each phase
4. Understand how phases connect and depend on each other
5. Apply SDLC phases to real-world project scenarios

---

## üîÑ The Complete SDLC Overview

### The Seven Phases

Every software development lifecycle consists of these fundamental phases:

```mermaid
graph TD
    A[1. Planning] --> B[2. Requirements Analysis]
    B --> C[3. Design]
    C --> D[4. Implementation]
    D --> E[5. Testing]
    E --> F[6. Deployment]
    F --> G[7. Maintenance]
    G -.Feedback Loop.-> B
    
    style A fill:#e3f2fd
    style B fill:#e1f5fe
    style C fill:#b2ebf2
    style D fill:#80deea
    style E fill:#4dd0e1
    style F fill:#26c6da
    style G fill:#00bcd4
```

### Phase Overview Table

| Phase | Primary Question | Key Activities | Duration (Typical) |
|-------|-----------------|----------------|-------------------|
| **1. Planning** | Why build this? | Feasibility, budgeting, scheduling | 1-2 weeks |
| **2. Requirements** | What to build? | Gathering, documenting, validating needs | 2-4 weeks |
| **3. Design** | How to build it? | Architecture, UI/UX, database design | 2-6 weeks |
| **4. Implementation** | Building it | Coding, code reviews, integration | 8-20 weeks |
| **5. Testing** | Does it work? | Unit, integration, system, UAT | 2-6 weeks |
| **6. Deployment** | Release to users | Installation, configuration, go-live | 1-2 weeks |
| **7. Maintenance** | Keep it working | Bug fixes, updates, enhancements | Ongoing |

---

## üìã Phase 1: Planning

### Purpose
Establish project viability and create a roadmap for success.

### Key Question
**"Should we build this software? Is it feasible and worth the investment?"**

```mermaid
mindmap
  root((Planning<br/>Phase))
    Feasibility
      Technical: Can we build it?
      Economic: Is it profitable?
      Operational: Can users use it?
      Legal: Any compliance issues?
      Schedule: Can we meet deadlines?
    Resources
      Team size
      Budget allocation
      Time estimates
      Tools & infrastructure
    Risks
      Identify threats
      Assess probability
      Plan mitigation
      Contingency plans
    Goals
      Business objectives
      Success metrics
      Project scope
      Constraints
```

### Core Activities

#### 1. Feasibility Study

**Technical Feasibility:**
- Do we have the technical expertise?
- Is the technology mature enough?
- Can it integrate with existing systems?

**Economic Feasibility:**
- Cost-Benefit Analysis
- Return on Investment (ROI)
- Total Cost of Ownership (TCO)

**Example - School Management System:**

| Cost Category | Amount | Benefit Category | Value/Year |
|---------------|--------|------------------|------------|
| Development | $150,000 | Admin time saved | $45,000 |
| Infrastructure | $20,000 | Teacher efficiency | $35,000 |
| Training | $10,000 | Parent satisfaction | $12,000 |
| **Total Cost** | **$180,000** | **Total Benefit** | **$92,000** |
| | | **ROI (2 years)** | **2.3% positive** |

#### 2. Project Charter Development

A project charter typically includes:

```mermaid
graph LR
    A[Project Charter] --> B[Vision & Objectives]
    A --> C[Scope Statement]
    A --> D[Stakeholders]
    A --> E[High-Level Timeline]
    A --> F[Budget Estimate]
    A --> G[Success Criteria]
    A --> H[Key Risks]
    
    style A fill:#4caf50
    style B fill:#81c784
    style C fill:#81c784
    style D fill:#81c784
    style E fill:#81c784
    style F fill:#81c784
    style G fill:#81c784
    style H fill:#81c784
```

#### 3. Stakeholder Identification

**Example Stakeholder Map:**

```mermaid
quadrantChart
    title Stakeholder Analysis Matrix
    x-axis Low Interest --> High Interest
    y-axis Low Power --> High Power
    quadrant-1 Manage Closely
    quadrant-2 Keep Satisfied
    quadrant-3 Monitor
    quadrant-4 Keep Informed
    School Principal: [0.9, 0.9]
    Teachers: [0.8, 0.6]
    Parents: [0.7, 0.3]
    Students: [0.8, 0.2]
    IT Staff: [0.6, 0.7]
    School Board: [0.5, 0.8]
    Regulatory Bodies: [0.4, 0.7]
```

### Deliverables

- ‚úÖ Project Charter
- ‚úÖ Feasibility Study Report
- ‚úÖ Preliminary Budget
- ‚úÖ High-Level Timeline
- ‚úÖ Stakeholder Register
- ‚úÖ Initial Risk Register

### Real-World Example

**Spotify's Planning Phase (2006):**
- **Vision:** Legal music streaming service
- **Feasibility:** Secured music label agreements (biggest risk)
- **Budget:** $10M initial funding
- **Timeline:** 18 months to launch
- **Success Metric:** 1M users in first year
- **Result:** Launched April 2008, achieved goal by 2009

---

## üìä Phase 2: Requirements Analysis

### Purpose
Define WHAT the software must do (not HOW).

### Key Question
**"What exactly do users need the system to do?"**

```mermaid
graph TD
    A[Requirements Analysis] --> B[Functional Requirements]
    A --> C[Non-Functional Requirements]
    A --> D[Business Rules]
    A --> E[Constraints]
    
    B --> F[User Actions<br/>System Behaviors<br/>Business Processes]
    C --> G[Performance<br/>Security<br/>Usability<br/>Reliability]
    D --> H[Policies<br/>Regulations<br/>Standards]
    E --> I[Budget<br/>Time<br/>Technology<br/>Resources]
    
    style A fill:#2196f3
    style B fill:#64b5f6
    style C fill:#64b5f6
    style D fill:#64b5f6
    style E fill:#64b5f6
```

### Core Activities

#### 1. Requirements Elicitation Techniques

| Technique | Best For | Example |
|-----------|----------|---------|
| **Interviews** | In-depth understanding from key stakeholders | One-on-one with school principal |
| **Surveys/Questionnaires** | Gathering input from many users | Survey 100+ teachers |
| **Workshops** | Collaborative requirement definition | Day-long session with teachers |
| **Observation** | Understanding actual work processes | Shadow teachers for a day |
| **Document Analysis** | Understanding existing processes | Review current paper forms |
| **Prototyping** | Validating UI/UX concepts | Clickable mockup of dashboard |

#### 2. Functional vs. Non-Functional Requirements

**Functional Requirements (What the system does):**

**School Management System Examples:**

| ID | Requirement | Priority |
|----|-------------|----------|
| FR-01 | System shall allow teachers to take attendance | Must Have |
| FR-02 | System shall calculate final grades automatically | Must Have |
| FR-03 | System shall send email notifications to parents | Should Have |
| FR-04 | System shall generate report cards in PDF format | Must Have |
| FR-05 | System shall allow students to view their grades | Should Have |
| FR-06 | System shall track student behavior incidents | Could Have |

**Non-Functional Requirements (How well the system performs):**

```mermaid
mindmap
  root((Non-Functional<br/>Requirements))
    Performance
      Response time < 2 sec
      Support 500 concurrent users
      Process 1000 grades/min
    Security
      Role-based access control
      Data encryption at rest
      HTTPS for all connections
      Password complexity rules
    Usability
      Training time < 2 hours
      Mobile responsive design
      Accessibility WCAG 2.1 AA
    Reliability
      99.5% uptime
      Daily automated backups
      Disaster recovery in 4 hours
    Scalability
      Support up to 2000 students
      Add new schools easily
      Handle 10x peak loads
    Maintainability
      Modular architecture
      Code documentation
      Automated testing
```

#### 3. Requirements Documentation

**User Story Format (Agile Approach):**

```
As a [role]
I want [feature]
So that [benefit]

Acceptance Criteria:
- Given [context]
- When [action]
- Then [outcome]
```

**Example User Story:**

```
US-019: Take Attendance

As a teacher
I want to quickly record student attendance for my class
So that I can track attendance patterns and parents stay informed

Acceptance Criteria:
- Given I am viewing my class roster
- When I mark students as present/absent/late
- Then the system saves attendance with timestamp
- And parents receive notification for absences within 1 hour
- And attendance is visible in student records immediately
- And I can edit attendance for up to 24 hours after recording
```

#### 4. Requirements Prioritization (MoSCoW Method)

```mermaid
pie title Requirements Distribution
    "Must Have (60%)" : 60
    "Should Have (20%)" : 20
    "Could Have (15%)" : 15
    "Won't Have (5%)" : 5
```

**Criteria for Prioritization:**
1. **Business Value:** Impact on core objectives
2. **Risk:** Technical or business risk reduction
3. **Dependencies:** Required for other features
4. **User Impact:** Number of users affected
5. **Regulatory:** Compliance requirements

### Deliverables

- ‚úÖ Software Requirements Specification (SRS)
- ‚úÖ User Stories with Acceptance Criteria
- ‚úÖ Use Case Diagrams (detailed in Chapter 3)
- ‚úÖ Requirements Traceability Matrix
- ‚úÖ Glossary of Terms
- ‚úÖ Data Dictionary

### Common Pitfalls

‚ùå **Ambiguous Requirements:**
- Bad: "System should be fast"
- Good: "System should load dashboard in < 2 seconds for 95% of requests"

‚ùå **Gold Plating:**
- Adding features users didn't ask for
- "Nice to have" becomes "must have"

‚ùå **Scope Creep:**
- Uncontrolled changes to requirements
- No formal change control process

---

## üé® Phase 3: Design

### Purpose
Define HOW the system will work to meet the requirements.

### Key Question
**"How will we structure and build this system?"**

```mermaid
graph TD
    A[Design Phase] --> B[High-Level Design]
    A --> C[Detailed Design]
    
    B --> D[System Architecture]
    B --> E[Technology Stack]
    B --> F[Integration Points]
    
    C --> G[Database Design]
    C --> H[UI/UX Design]
    C --> I[API Design]
    C --> J[Component Design]
    
    style A fill:#9c27b0
    style B fill:#ba68c8
    style C fill:#ce93d8
```

### Core Activities

#### 1. System Architecture Design

**Three-Tier Architecture Example (School Management System):**

```mermaid
graph TB
    subgraph Presentation Layer
        A[Web Browser]
        B[Mobile App]
    end
    
    subgraph Application Layer
        C[API Gateway]
        D[Auth Service]
        E[Student Service]
        F[Grade Service]
        G[Attendance Service]
        H[Notification Service]
    end
    
    subgraph Data Layer
        I[(MySQL Database)]
        J[(File Storage)]
        K[Cache Redis]
    end
    
    A --> C
    B --> C
    C --> D
    C --> E
    C --> F
    C --> G
    C --> H
    
    D --> I
    E --> I
    F --> I
    G --> I
    H --> J
    E --> K
    
    style A fill:#e3f2fd
    style B fill:#e3f2fd
    style C fill:#fff9c4
    style D fill:#c8e6c9
    style E fill:#c8e6c9
    style F fill:#c8e6c9
    style G fill:#c8e6c9
    style H fill:#c8e6c9
    style I fill:#ffccbc
    style J fill:#ffccbc
    style K fill:#ffccbc
```

#### 2. Technology Stack Selection

**Example Technology Stack:**

| Layer | Technology | Justification |
|-------|------------|---------------|
| **Frontend** | React.js | Component-based, large community, fast |
| **Backend** | Node.js + Express | JavaScript full-stack, scalable, async |
| **Database** | MySQL | Relational data, ACID compliance, mature |
| **Cache** | Redis | Fast, simple, supports sessions |
| **File Storage** | AWS S3 | Scalable, reliable, cost-effective |
| **Authentication** | JWT + bcrypt | Stateless, secure, industry standard |
| **API Style** | RESTful | Standard, well-understood, tooling |

#### 3. Database Design

**Entity-Relationship Diagram Example:**

```mermaid
erDiagram
    STUDENT ||--o{ ENROLLMENT : "enrolls in"
    TEACHER ||--o{ CLASS : "teaches"
    CLASS ||--o{ ENROLLMENT : "has"
    ENROLLMENT ||--o{ ATTENDANCE : "tracks"
    ENROLLMENT ||--o{ GRADE : "earns"
    STUDENT ||--o{ PARENT_LINK : "linked to"
    PARENT ||--o{ PARENT_LINK : "linked to"
    
    STUDENT {
        int student_id PK
        string first_name
        string last_name
        date date_of_birth
        string email
        date enrollment_date
    }
    
    TEACHER {
        int teacher_id PK
        string first_name
        string last_name
        string email
        string department
    }
    
    CLASS {
        int class_id PK
        string class_name
        string section
        int teacher_id FK
        int academic_year
        string semester
    }
    
    ENROLLMENT {
        int enrollment_id PK
        int student_id FK
        int class_id FK
        date enrollment_date
    }
    
    ATTENDANCE {
        int attendance_id PK
        int enrollment_id FK
        date attendance_date
        string status
        time recorded_at
    }
    
    GRADE {
        int grade_id PK
        int enrollment_id FK
        string category
        decimal score
        decimal max_score
        date recorded_date
    }
```

#### 4. User Interface Design

**Wireframe Example - Teacher Dashboard:**

```mermaid
graph TD
    A[Header: School Logo | Teacher Name | Logout]
    B[Navigation: Classes | Attendance | Grades | Reports]
    C[Main Content: My Classes Grid]
    D[Card 1: Math 101-A<br/>25 Students<br/>Quick Actions]
    E[Card 2: Math 102-B<br/>28 Students<br/>Quick Actions]
    F[Card 3: Algebra-C<br/>22 Students<br/>Quick Actions]
    G[Sidebar: Quick Stats<br/>Today's Schedule<br/>Recent Activity]
    
    A --> B
    B --> C
    C --> D
    C --> E
    C --> F
    C --> G
    
    style A fill:#2196f3
    style B fill:#64b5f6
    style C fill:#e3f2fd
    style D fill:#bbdefb
    style E fill:#bbdefb
    style F fill:#bbdefb
    style G fill:#90caf9
```

#### 5. API Design

**RESTful API Endpoint Structure:**

```mermaid
graph LR
    A[API Gateway<br/>api.school.com] --> B[/auth/*]
    A --> C[/students/*]
    A --> D[/teachers/*]
    A --> E[/classes/*]
    A --> F[/attendance/*]
    A --> G[/grades/*]
    
    B --> B1[POST /login<br/>POST /logout<br/>POST /reset-password]
    C --> C1[GET /students<br/>GET /students/:id<br/>POST /students<br/>PUT /students/:id]
    F --> F1[POST /attendance<br/>GET /attendance/class/:id<br/>PUT /attendance/:id]
    
    style A fill:#4caf50
    style B fill:#81c784
    style C fill:#81c784
    style D fill:#81c784
    style E fill:#81c784
    style F fill:#81c784
    style G fill:#81c784
```

**Example API Specification:**

```
Endpoint: POST /api/attendance
Description: Record attendance for a class session
Authentication: Required (JWT token)
Authorization: Teacher role, assigned to the class

Request Body:
{
  "class_id": 101,
  "attendance_date": "2025-11-10",
  "records": [
    {"student_id": 1001, "status": "present"},
    {"student_id": 1002, "status": "absent"},
    {"student_id": 1003, "status": "late"}
  ]
}

Response (200 OK):
{
  "success": true,
  "attendance_id": 5678,
  "recorded_at": "2025-11-10T09:15:30Z",
  "notifications_sent": 1
}

Error Response (403 Forbidden):
{
  "success": false,
  "error": "Not authorized to record attendance for this class"
}
```

### Deliverables

- ‚úÖ System Architecture Document
- ‚úÖ Database Schema (ERD + SQL scripts)
- ‚úÖ UI/UX Wireframes and Mockups
- ‚úÖ API Specification
- ‚úÖ Component Design Documents
- ‚úÖ Design Patterns Documentation
- ‚úÖ Security Design Document

### Design Principles

```mermaid
mindmap
  root((Design<br/>Principles))
    SOLID
      Single Responsibility
      Open/Closed
      Liskov Substitution
      Interface Segregation
      Dependency Inversion
    Others
      DRY: Don't Repeat Yourself
      KISS: Keep It Simple
      YAGNI: You Aren't Gonna Need It
      Separation of Concerns
      Loose Coupling, High Cohesion
```

---

## üíª Phase 4: Implementation (Development)

### Purpose
Transform design into working software through coding.

### Key Question
**"Let's build it!"**

```mermaid
graph LR
    A[Design Documents] --> B[Setup Environment]
    B --> C[Write Code]
    C --> D[Code Review]
    D --> E[Unit Testing]
    E --> F{Pass?}
    F -->|No| C
    F -->|Yes| G[Integration]
    G --> H[Version Control]
    
    style A fill:#fff9c4
    style C fill:#c8e6c9
    style D fill:#81c784
    style E fill:#4caf50
    style F fill:#ffcc80
    style G fill:#66bb6a
    style H fill:#2e7d32
```

### Core Activities

#### 1. Development Environment Setup

**Typical Setup Checklist:**

```mermaid
graph TD
    A[Development Environment] --> B[Local Setup]
    A --> C[Version Control]
    A --> D[CI/CD Pipeline]
    
    B --> B1[IDE: VS Code]
    B --> B2[Node.js v18+]
    B --> B3[MySQL 8.0]
    B --> B4[Git client]
    
    C --> C1[GitHub Repository]
    C --> C2[Branching Strategy]
    C --> C3[.gitignore configured]
    
    D --> D1[GitHub Actions]
    D --> D2[Automated Tests]
    D --> D3[Code Quality Checks]
    
    style A fill:#2196f3
    style B fill:#64b5f6
    style C fill:#90caf9
    style D fill:#bbdefb
```

#### 2. Coding Standards

**Example Code Structure:**

```
school-management-system/
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ App.js
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ server.js
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ seeds/
‚îÇ   ‚îî‚îÄ‚îÄ schema.sql
‚îú‚îÄ‚îÄ docs/
‚îî‚îÄ‚îÄ README.md
```

#### 3. Version Control Workflow (Git Flow)

```mermaid
gitGraph
    commit id: "Initial commit"
    branch develop
    checkout develop
    commit id: "Setup project"
    branch feature/authentication
    checkout feature/authentication
    commit id: "Add login"
    commit id: "Add logout"
    checkout develop
    merge feature/authentication
    branch feature/attendance
    checkout feature/attendance
    commit id: "Create attendance model"
    commit id: "Add attendance API"
    checkout develop
    merge feature/attendance
    checkout main
    merge develop tag: "v1.0.0"
```

#### 4. Code Review Process

**Code Review Checklist:**

| Category | Check Points |
|----------|--------------|
| **Functionality** | ‚úì Meets requirements<br/>‚úì Handles edge cases<br/>‚úì Error handling present |
| **Code Quality** | ‚úì Follows style guide<br/>‚úì DRY principle applied<br/>‚úì Proper naming conventions |
| **Testing** | ‚úì Unit tests included<br/>‚úì Test coverage >80%<br/>‚úì Tests pass |
| **Security** | ‚úì Input validation<br/>‚úì SQL injection prevention<br/>‚úì Authentication checked |
| **Performance** | ‚úì No N+1 queries<br/>‚úì Appropriate caching<br/>‚úì Async operations used |
| **Documentation** | ‚úì Code comments<br/>‚úì API docs updated<br/>‚úì README updated |

### Deliverables

- ‚úÖ Source Code (in version control)
- ‚úÖ Unit Tests
- ‚úÖ Code Documentation
- ‚úÖ Build Scripts
- ‚úÖ API Documentation (updated)
- ‚úÖ Developer Guide

### Development Best Practices

```mermaid
mindmap
  root((Best<br/>Practices))
    Code Quality
      Linting ESLint/Prettier
      Type checking TypeScript
      Code reviews mandatory
      Static analysis SonarQube
    Testing
      Unit tests Jest
      Integration tests
      Test coverage >80%
      TDD when possible
    Documentation
      Inline comments
      API documentation
      README files
      Architecture docs
    Version Control
      Meaningful commits
      Feature branches
      Pull requests
      Code review required
```

---

## üß™ Phase 5: Testing

### Purpose
Verify the software works correctly and meets requirements.

### Key Question
**"Does it work as expected? Are there any bugs?"**

```mermaid
graph TD
    A[Testing Phase] --> B[Unit Testing]
    A --> C[Integration Testing]
    A --> D[System Testing]
    A --> E[Acceptance Testing]
    
    B --> F[Test Individual<br/>Components]
    C --> G[Test Component<br/>Interactions]
    D --> H[Test Complete<br/>System]
    E --> I[Test User<br/>Requirements]
    
    F --> J{Bugs Found?}
    G --> J
    H --> J
    I --> J
    
    J -->|Yes| K[Fix Bugs]
    K --> A
    J -->|No| L[Ready for Deployment]
    
    style A fill:#ff9800
    style B fill:#ffb74d
    style C fill:#ffb74d
    style D fill:#ffb74d
    style E fill:#ffb74d
    style L fill:#66bb6a
```

### Testing Levels

#### 1. Unit Testing

**Purpose:** Test individual functions/methods in isolation

**Example Unit Test (Jest/JavaScript):**

```javascript
// Function to test
function calculateFinalGrade(grades, weights) {
  let totalScore = 0;
  let totalWeight = 0;
  
  for (let i = 0; i < grades.length; i++) {
    totalScore += grades[i] * weights[i];
    totalWeight += weights[i];
  }
  
  return totalScore / totalWeight;
}

// Unit test
describe('calculateFinalGrade', () => {
  test('calculates weighted average correctly', () => {
    const grades = [90, 85, 95];
    const weights = [0.3, 0.3, 0.4];
    const result = calculateFinalGrade(grades, weights);
    expect(result).toBeCloseTo(90);
  });
  
  test('handles single grade', () => {
    const grades = [95];
    const weights = [1.0];
    const result = calculateFinalGrade(grades, weights);
    expect(result).toBe(95);
  });
});
```

#### 2. Integration Testing

**Purpose:** Test how components work together

**Example Scenarios:**
- Test attendance API endpoint with database
- Test authentication middleware with protected routes
- Test grade calculation with notification service

#### 3. System Testing

**Purpose:** Test the complete, integrated system

**Test Types:**

```mermaid
mindmap
  root((System<br/>Testing))
    Functional
      Feature testing
      End-to-end workflows
      Business rules
    Non-Functional
      Performance testing
      Load testing
      Stress testing
      Security testing
      Usability testing
    Regression
      Re-test after fixes
      Automated test suite
      Smoke testing
```

#### 4. User Acceptance Testing (UAT)

**Purpose:** Validate system meets business requirements

**UAT Process:**

```mermaid
graph LR
    A[Prepare Test Cases] --> B[Train Users]
    B --> C[Execute Tests]
    C --> D[Document Results]
    D --> E{Acceptable?}
    E -->|No| F[Log Defects]
    F --> G[Fix Issues]
    G --> C
    E -->|Yes| H[Sign-off]
    
    style A fill:#e3f2fd
    style C fill:#fff9c4
    style E fill:#ffcc80
    style H fill:#c8e6c9
```

### Testing Metrics

**Key Metrics to Track:**

| Metric | Target | Purpose |
|--------|--------|---------|
| **Code Coverage** | >80% | Ensure adequate testing |
| **Defect Density** | <5 per KLOC | Measure code quality |
| **Test Pass Rate** | >95% | Track testing effectiveness |
| **Defect Detection %** | >90% | Testing efficiency |
| **Mean Time to Detect** | <2 days | Bug identification speed |
| **Mean Time to Fix** | <5 days | Bug resolution speed |

### Deliverables

- ‚úÖ Test Plans and Test Cases
- ‚úÖ Test Scripts (automated)
- ‚úÖ Test Reports
- ‚úÖ Defect Reports
- ‚úÖ Test Coverage Reports
- ‚úÖ UAT Sign-off Document

---

## üöÄ Phase 6: Deployment

### Purpose
Release the software to production environment for end users.

### Key Question
**"How do we safely release this to users?"**

```mermaid
graph TD
    A[Deployment Ready] --> B[Pre-Deployment]
    B --> C[Deployment]
    C --> D[Post-Deployment]
    
    B --> B1[Backup Production]
    B --> B2[Final Testing]
    B --> B3[User Notification]
    B --> B4[Rollback Plan]
    
    C --> C1[Deploy to Production]
    C --> C2[Database Migration]
    C --> C3[Configure Systems]
    C --> C4[Smoke Testing]
    
    D --> D1[Monitor Systems]
    D --> D2[User Support]
    D --> D3[Performance Check]
    D --> D4[Document Issues]
    
    style A fill:#4caf50
    style B fill:#81c784
    style C fill:#ffb74d
    style D fill:#64b5f6
```

### Deployment Strategies

#### 1. Blue-Green Deployment

```mermaid
graph LR
    A[Load Balancer] --> B[Blue Environment<br/>Current Version]
    A -.Switch.-> C[Green Environment<br/>New Version]
    
    D[Users] --> A
    
    B --> E[(Database)]
    C --> E
    
    style B fill:#2196f3
    style C fill:#4caf50
    style A fill:#ff9800
```

**Advantages:**
- Zero downtime
- Easy rollback (just switch back)
- Full testing in production environment

#### 2. Rolling Deployment

```mermaid
graph TD
    A[Start: All Servers v1.0] --> B[Update Server 1 to v2.0]
    B --> C[Test Server 1]
    C --> D{Working?}
    D -->|Yes| E[Update Server 2 to v2.0]
    D -->|No| F[Rollback Server 1]
    E --> G[Update Server 3 to v2.0]
    G --> H[All Servers v2.0]
    
    style A fill:#2196f3
    style H fill:#4caf50
    style F fill:#f44336
```

#### 3. Canary Deployment

**Phase Rollout:**

```mermaid
pie title User Distribution During Canary Deployment
    "Old Version" : 90
    "New Version (Canary)" : 10
```

**Process:**
1. Deploy to 10% of users
2. Monitor for issues (24 hours)
3. If stable, deploy to 50%
4. Monitor for issues (24 hours)
5. If stable, deploy to 100%

### Deployment Checklist

**Pre-Deployment:**
- [ ] All tests passed
- [ ] UAT sign-off obtained
- [ ] Backup completed
- [ ] Rollback plan documented
- [ ] Deployment runbook prepared
- [ ] Stakeholders notified
- [ ] Support team briefed
- [ ] Maintenance window scheduled

**During Deployment:**
- [ ] Follow deployment runbook
- [ ] Execute database migrations
- [ ] Deploy application code
- [ ] Update configuration
- [ ] Run smoke tests
- [ ] Monitor system metrics

**Post-Deployment:**
- [ ] Verify core functionality
- [ ] Check system performance
- [ ] Monitor error rates
- [ ] Review user feedback
- [ ] Document any issues
- [ ] Send completion notification

### Deliverables

- ‚úÖ Deployment Plan
- ‚úÖ Release Notes
- ‚úÖ User Documentation
- ‚úÖ Training Materials
- ‚úÖ System Administration Guide
- ‚úÖ Rollback Procedures
- ‚úÖ Post-Deployment Report

---

## üîß Phase 7: Maintenance

### Purpose
Keep the system running smoothly and evolving with user needs.

### Key Question
**"How do we keep this system healthy and improving?"**

```mermaid
mindmap
  root((Maintenance<br/>Phase))
    Corrective
      Bug fixes
      Error corrections
      Performance issues
    Adaptive
      OS updates
      Database upgrades
      API changes
      Compliance updates
    Perfective
      Feature enhancements
      UI improvements
      Performance optimization
      Refactoring
    Preventive
      Code cleanup
      Documentation updates
      Security patches
      Dependency updates
```

### Types of Maintenance

#### 1. Corrective Maintenance (Bug Fixes)

**Bug Priority System:**

| Priority | Response Time | Resolution Time | Example |
|----------|--------------|-----------------|---------|
| **Critical (P0)** | 1 hour | 4 hours | System down, data loss |
| **High (P1)** | 4 hours | 24 hours | Major feature broken |
| **Medium (P2)** | 1 day | 1 week | Minor feature issue |
| **Low (P3)** | 1 week | Next release | Cosmetic issues |

#### 2. Adaptive Maintenance (Environment Changes)

**Example Adaptive Changes:**
- Update to new React version
- Migrate from MySQL 5.7 to 8.0
- Adapt to new browser security policies
- Comply with new data privacy regulations

#### 3. Perfective Maintenance (Improvements)

**Enhancement Request Process:**

```mermaid
graph LR
    A[User Request] --> B[Log Ticket]
    B --> C[Prioritize]
    C --> D[Estimate Effort]
    D --> E{Approved?}
    E -->|Yes| F[Add to Backlog]
    E -->|No| G[Decline with Reason]
    F --> H[Plan for Sprint]
    H --> I[Implement]
    I --> J[Deploy]
    
    style A fill:#e3f2fd
    style E fill:#fff9c4
    style I fill:#c8e6c9
    style J fill:#81c784
```

#### 4. Preventive Maintenance (Future-proofing)

**Monthly Maintenance Tasks:**
- Security patches
- Dependency updates
- Database optimization
- Log file cleanup
- Performance monitoring review
- Backup verification
- Documentation updates

### Maintenance Metrics

**Key Performance Indicators:**

```mermaid
graph TD
    A[Maintenance KPIs] --> B[System Uptime<br/>Target: 99.5%]
    A --> C[Mean Time to Repair<br/>Target: <4 hours]
    A --> D[User Satisfaction<br/>Target: >4.0/5.0]
    A --> E[Response Time<br/>Target: <2 seconds]
    A --> F[Bug Recurrence Rate<br/>Target: <5%]
    
    style A fill:#2196f3
    style B fill:#4caf50
    style C fill:#4caf50
    style D fill:#4caf50
    style E fill:#4caf50
    style F fill:#4caf50
```

### Support Structure

**Three-Tier Support Model:**

| Tier | Role | Responsibilities | Escalation Time |
|------|------|------------------|-----------------|
| **Tier 1** | Help Desk | Answer basic questions, password resets | 30 min if unresolved |
| **Tier 2** | Technical Support | Debug issues, workarounds, minor fixes | 2 hours if unresolved |
| **Tier 3** | Development Team | Code fixes, system issues, architecture | Varies by priority |

### Deliverables (Ongoing)

- ‚úÖ Bug Fix Releases
- ‚úÖ Maintenance Reports
- ‚úÖ Performance Reports
- ‚úÖ Update Documentation
- ‚úÖ User Feedback Analysis
- ‚úÖ Enhancement Proposals

---

## üîÑ Phase Interactions and Dependencies

### How Phases Connect

```mermaid
graph TD
    A[Planning] -->|Project Charter| B[Requirements]
    B -->|SRS Document| C[Design]
    C -->|Design Specs| D[Implementation]
    D -->|Source Code| E[Testing]
    E -->|Test Results| D
    E -->|Quality Approved| F[Deployment]
    F -->|Production System| G[Maintenance]
    G -->|Change Requests| B
    G -->|Bug Reports| D
    
    style A fill:#e3f2fd
    style B fill:#e1f5fe
    style C fill:#b2ebf2
    style D fill:#80deea
    style E fill:#4dd0e1
    style F fill:#26c6da
    style G fill:#00bcd4
```

### Critical Handoffs

**Key Documents Between Phases:**

| From Phase | To Phase | Document | Purpose |
|------------|----------|----------|---------|
| Planning | Requirements | Project Charter | Scope and objectives |
| Requirements | Design | SRS Document | What to build |
| Design | Implementation | Design Specifications | How to build |
| Implementation | Testing | Source Code + Docs | What to test |
| Testing | Deployment | Test Reports | Quality verification |
| Deployment | Maintenance | System Docs | How to support |

---

## üéì Hands-On Activity: Phase Mapping

### Activity: "Where Does This Belong?"

**Time:** 15 minutes  
**Format:** Individual or pairs

**Instructions:**
For each activity below, identify which SDLC phase it belongs to:

| Activity | SDLC Phase | Deliverable |
|----------|------------|-------------|
| Creating wireframes | | |
| Fixing a production bug | | |
| Conducting stakeholder interviews | | |
| Writing unit tests | | |
| Performing load testing | | |
| Calculating project ROI | | |
| Writing JavaScript code | | |
| Updating user documentation | | |
| Creating database schema | | |
| Deploying to production servers | | |
| Prioritizing feature requests | | |
| Code review session | | |

**Answers at end of Section 1.10**

---

## üîë Key Concepts Summary

### Critical Points to Remember

1. **Seven phases make up SDLC:** Planning, Requirements, Design, Implementation, Testing, Deployment, Maintenance

2. **Each phase has distinct objectives:**
   - Planning: Should we build this?
   - Requirements: What should we build?
   - Design: How should we build it?
   - Implementation: Build it!
   - Testing: Does it work?
   - Deployment: Release it!
   - Maintenance: Keep it working!

3. **Phases are interdependent:** Each phase builds on the previous one

4. **Documentation is critical:** Each phase produces deliverables used by subsequent phases

5. **Feedback loops exist:** Issues found in later phases may require revisiting earlier phases

6. **Not always strictly sequential:** Modern methodologies (Agile) may iterate through phases multiple times

### Phase Duration Distribution (Typical)

```mermaid
pie title Time Allocation by Phase (%)
    "Planning" : 5
    "Requirements" : 10
    "Design" : 15
    "Implementation" : 40
    "Testing" : 20
    "Deployment" : 5
    "Maintenance" : 5
```

*Note: Maintenance continues long-term, so its percentage represents initial setup*

---

## ‚úÖ Self-Check Questions

Test your understanding:

1. What are the seven phases of SDLC in order?
2. Which phase answers "What should we build?" vs. "How should we build it?"
3. What is the difference between corrective and preventive maintenance?
4. Why is it important to create documentation in each phase?
5. In which phase would you create an Entity-Relationship Diagram?
6. What happens if requirements are poorly defined in Phase 2?
7. Name three types of testing that occur in the Testing phase.
8. What is the purpose of a rollback plan in the Deployment phase?

**Answers at the end of Section 1.10**

---

## üöÄ What's Next?

Now that you understand the fundamental phases of SDLC, the next section explores different SDLC models‚Äîvarious ways to organize and execute these phases. You'll learn about traditional models like Waterfall, Spiral, and V-Model.

**Next Section:** [1.3 Traditional SDLC Models ‚Üí](./1.3-traditional-models.md)

---

## üìö Additional Resources

**For Deeper Learning:**
- IEEE Standard 12207 (Systems and Software Engineering - Software Life Cycle Processes)
- ISO/IEC/IEEE 15288 (Systems and Software Engineering - System Life Cycle Processes)
- SWEBOK (Software Engineering Body of Knowledge) - Chapter on Software Process

**Recommended Reading:**
- "Software Engineering" by Ian Sommerville - Chapters 2-4
- "The Pragmatic Programmer" by Hunt & Thomas - Process sections

---

[‚Üê Previous: 1.1 Why SDLC Matters](./1.1-why-sdlc-matters.md) | [Back to README](./chapter-01-README.md) | [Next: 1.3 Traditional Models ‚Üí](./1.3-traditional-models.md)

---

*Last Updated: November 2025*  
*Version: 1.0*
